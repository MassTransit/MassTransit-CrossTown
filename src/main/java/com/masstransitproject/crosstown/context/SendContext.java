package com.masstransitproject.crosstown.context;

import java.io.IOException;
import java.io.OutputStream;
import java.net.URI;
import java.sql.Timestamp;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

import com.masstransitproject.crosstown.IMessage;

// Copyright 2007-2011 Chris Patterson, Dru Sellers, Travis Smith, et. al.
//  
// Licensed under the Apache License, Version 2.0 (the "License"); you may not use 
// this file except in compliance with the License. You may obtain a copy of the 
// License at 
// 
//     http://www.apache.org/licenses/LICENSE-2.0 
// 
// Unless required by applicable law or agreed to in writing, software distributed 
// under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR 
// CONDITIONS OF ANY KIND, either express or implied. See the License for the 
// specific language governing permissions and limitations under the License.

/// <summary>
/// The base message context, including all the message headers
/// </summary>
public class SendContext implements ISendContext, IMessageContext {
	// / <summary>
	// / The transport id of the message
	// / </summary>
	private String messageId;

	// / <summary>
	// / The type of the message in FullName, Assembly format
	// / </summary>
	private String messageType;

	// / <summary>
	// / The content type of the message from the transport
	// / </summary>
	private String contentType;

	// / <summary>
	// / The request identifier this message is either a request or a response
	// / </summary>
	private String requestId;

	// / <summary>
	// / The conversation identifier is a higher-level identifier for
	// trace/correlation of conversations
	// / </summary>
	private String conversationId;

	// / <summary>
	// / If the message is CorrelatedBy, this header contains the String version
	// of the correlation identifier
	// / </summary>
	private String correlationId;

	// / <summary>
	// / The address from which this message originated
	// / </summary>
	private URI sourceAddress;

	// / <summary>
	// / The address from which this message was most recently read
	// / </summary>
	private URI inputAddress;

	// / <summary>
	// / The address to which the message was originally sent
	// / </summary>
	private URI destinationAddress;

	// / <summary>
	// / The address where responses to this message should be sent
	// / </summary>
	private URI responseAddress;

	// / <summary>
	// / The address where faults generated by consumers of this message should
	// be sent
	// / </summary>
	private URI faultAddress;

	// / <summary>
	// / Identifies a specific network to which this message belongs and is used
	// to filter
	// / out messages that might be from un-trusted networks
	// / </summary>
	private String network;

	// / <summary>
	// / The expiration time of the message, if set, otherwise null
	// / </summary>
	private Timestamp expirationTime;

	// / <summary>
	// / The number of times this message has been delivered to the consumer
	// / </summary>
	private int retryCount;

	// / <summary>
	// / Key/value headers that are application-specific
	// / </summary>
	private Map<String, String> headers = new HashMap<String, String>();

	// / <summary>
	// / The identifier for this message publish/send
	// / </summary>
	private UUID id;

	// / <summary>
	// / The original message type that was sent/published
	// / </summary>
	@Override
	public Class<IMessage> getDeclaringMessageType() {
		return null;
	}

	@Override
	public UUID getId() {
		return id;
	}

	public void setId(UUID id) {
		this.id = id;
	}

	@Override
	public String getOriginalMessageId() {
		return originalMessageId;
	}

	public void setOriginalMessageId(String originalMessageId) {
		this.originalMessageId = originalMessageId;
	}

	private String originalMessageId;

	@Override
	public String getMessageId() {
		return messageId;
	}

	public void setMessageId(String messageId) {
		this.messageId = messageId;
	}

	@Override
	public String getMessageType() {
		return messageType;
	}

	@Override
	public void setMessageType(String messageType) {
		this.messageType = messageType;
	}

	@Override
	public String getContentType() {
		return contentType;
	}

	public void setContentType(String contentType) {
		this.contentType = contentType;
	}

	@Override
	public String getRequestId() {
		return requestId;
	}

	@Override
	public void setRequestId(String requestId) {
		this.requestId = requestId;
	}

	@Override
	public String getConversationId() {
		return conversationId;
	}

	@Override
	public void setConversationId(String conversationId) {
		this.conversationId = conversationId;
	}

	@Override
	public String getCorrelationId() {
		return correlationId;
	}

	@Override
	public void setCorrelationId(String correlationId) {
		this.correlationId = correlationId;
	}

	@Override
	public URI getSourceAddress() {
		return sourceAddress;
	}

	@Override
	public void setSourceAddress(URI sourceAddress) {
		this.sourceAddress = sourceAddress;
	}

	@Override
	public URI getInputAddress() {
		return inputAddress;
	}

	public void setInputAddress(URI inputAddress) {
		this.inputAddress = inputAddress;
	}

	@Override
	public URI getDestinationAddress() {
		return destinationAddress;
	}

	@Override
	public void setDestinationAddress(URI destinationAddress) {
		this.destinationAddress = destinationAddress;
	}

	@Override
	public URI getResponseAddress() {
		return responseAddress;
	}

	@Override
	public void setResponseAddress(URI responseAddress) {
		this.responseAddress = responseAddress;
	}

	@Override
	public URI getFaultAddress() {
		return faultAddress;
	}

	@Override
	public void setFaultAddress(URI faultAddress) {
		this.faultAddress = faultAddress;
	}

	@Override
	public String getNetwork() {
		return network;
	}

	@Override
	public void setNetwork(String network) {
		this.network = network;
	}

	@Override
	public Timestamp getExpirationTime() {
		return expirationTime;
	}

	@Override
	public void setExpirationTime(Timestamp expirationTime) {
		this.expirationTime = expirationTime;
	}

	@Override
	public int getRetryCount() {
		return retryCount;
	}

	@Override
	public void setRetryCount(int retryCount) {
		this.retryCount = retryCount;
	}

	@Override
	public Map<String, String> getHeaders() {
		return headers;
	}

	public void setHeaders(Map<String, String> headers) {
		this.headers = headers;
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result
				+ ((contentType == null) ? 0 : contentType.hashCode());
		result = prime * result
				+ ((conversationId == null) ? 0 : conversationId.hashCode());
		result = prime * result
				+ ((correlationId == null) ? 0 : correlationId.hashCode());
		result = prime
				* result
				+ ((destinationAddress == null) ? 0 : destinationAddress
						.hashCode());
		result = prime * result
				+ ((expirationTime == null) ? 0 : expirationTime.hashCode());
		result = prime * result
				+ ((faultAddress == null) ? 0 : faultAddress.hashCode());
		result = prime * result + ((headers == null) ? 0 : headers.hashCode());
		result = prime * result
				+ ((inputAddress == null) ? 0 : inputAddress.hashCode());
		result = prime * result
				+ ((messageId == null) ? 0 : messageId.hashCode());
		result = prime * result
				+ ((messageType == null) ? 0 : messageType.hashCode());
		result = prime * result + ((network == null) ? 0 : network.hashCode());
		result = prime * result
				+ ((requestId == null) ? 0 : requestId.hashCode());
		result = prime * result
				+ ((responseAddress == null) ? 0 : responseAddress.hashCode());
		result = prime * result + retryCount;
		result = prime * result
				+ ((sourceAddress == null) ? 0 : sourceAddress.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		SendContext other = (SendContext) obj;
		if (contentType == null) {
			if (other.contentType != null)
				return false;
		} else if (!contentType.equals(other.contentType))
			return false;
		if (conversationId == null) {
			if (other.conversationId != null)
				return false;
		} else if (!conversationId.equals(other.conversationId))
			return false;
		if (correlationId == null) {
			if (other.correlationId != null)
				return false;
		} else if (!correlationId.equals(other.correlationId))
			return false;
		if (destinationAddress == null) {
			if (other.destinationAddress != null)
				return false;
		} else if (!destinationAddress.equals(other.destinationAddress))
			return false;
		if (expirationTime == null) {
			if (other.expirationTime != null)
				return false;
		} else if (!expirationTime.equals(other.expirationTime))
			return false;
		if (faultAddress == null) {
			if (other.faultAddress != null)
				return false;
		} else if (!faultAddress.equals(other.faultAddress))
			return false;
		if (headers == null) {
			if (other.headers != null)
				return false;
		} else if (!headers.equals(other.headers))
			return false;
		if (inputAddress == null) {
			if (other.inputAddress != null)
				return false;
		} else if (!inputAddress.equals(other.inputAddress))
			return false;
		if (messageId == null) {
			if (other.messageId != null)
				return false;
		} else if (!messageId.equals(other.messageId))
			return false;
		if (messageType == null) {
			if (other.messageType != null)
				return false;
		} else if (!messageType.equals(other.messageType))
			return false;
		if (network == null) {
			if (other.network != null)
				return false;
		} else if (!network.equals(other.network))
			return false;
		if (requestId == null) {
			if (other.requestId != null)
				return false;
		} else if (!requestId.equals(other.requestId))
			return false;
		if (responseAddress == null) {
			if (other.responseAddress != null)
				return false;
		} else if (!responseAddress.equals(other.responseAddress))
			return false;
		if (retryCount != other.retryCount)
			return false;
		if (sourceAddress == null) {
			if (other.sourceAddress != null)
				return false;
		} else if (!sourceAddress.equals(other.sourceAddress))
			return false;
		return true;
	}

	@Override
	public String toString() {
		return "SendContext [messageId=" + messageId + ", messageType="
				+ messageType + ", contentType=" + contentType + ", requestId="
				+ requestId + ", conversationId=" + conversationId
				+ ", correlationId=" + correlationId + ", sourceAddress="
				+ sourceAddress + ", inputAddress=" + inputAddress
				+ ", destinationAddress=" + destinationAddress
				+ ", responseAddress=" + responseAddress + ", faultAddress="
				+ faultAddress + ", network=" + network + ", expirationTime="
				+ expirationTime + ", retryCount=" + retryCount + ", headers="
				+ headers + "]";
	}

	@Override
	public void setUsing(IMessageContext context) {
		// TODO Auto-generated method stub

	}

	@Override
	public void setHeader(String key, String value) {
		getHeaders().put(key, value);

	}

	@Override
	public void serializeTo(OutputStream stream) throws IOException {
		// TODO Auto-generated method stub

	}

}